/*
 * Iterable tuple
 * Copyright (C) 2017  Matija Skala <mskala@gmx.com>
 *
 * This library is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef NON_STD_ITUPLE
#define NON_STD_ITUPLE

#include <tuple>

namespace non_std
{

template <typename...>
struct AllEq_;

template <typename FirstArg, typename... OtherArgs>
struct AllEq_<FirstArg,OtherArgs...> {
    bool operator() ( FirstArg&& first, OtherArgs&&... args ) {
        for ( bool ne: { (first != args)... } )
            if ( ne ) return false;
        return true;
    }
};

template <typename OnlyOneArg>
struct AllEq_<OnlyOneArg> {
    bool operator() ( OnlyOneArg&& ) { return true; }
};

template <>
struct AllEq_<> {
    bool operator() () { return true; }
};

template <typename... Args>
bool all_eq ( Args... args ) { return AllEq_<Args...>() ( std::forward<Args>(args)... ); }

template <template <typename...> class, typename...>
struct ITupleHelper_;

template <template <typename...> class Tp>
struct ITupleHelper_<Tp> {
    template <bool...>
    struct IteratorHelper {
        template <typename... Args>
        struct Iterator {
            using type = Tp<Args...>;
        };
    };
};

template <template <typename...> class Tp, typename Type>
struct ITupleHelper_<Tp,Type> {
    template <bool Const>
    struct IteratorHelper {
        template <typename... Args>
        struct Iterator {
            using FirstT = typename std::remove_reference<Type>::type;
            using type = Tp<Args..., typename std::conditional<Const || std::is_const<FirstT>{},
                         typename FirstT::const_iterator, typename FirstT::iterator>::type>;
        };
    };
};

template <template <typename...> class Tp, typename FirstType, typename... OtherTypes>
struct ITupleHelper_<Tp,FirstType,OtherTypes...> {
    template <bool FirstConst, bool... OtherConst>
    struct IteratorHelper {
        template <typename... Args>
        struct Iterator {
            using FirstT = typename std::remove_reference<FirstType>::type;
            using type = typename ITupleHelper_<Tp, OtherTypes...>::template IteratorHelper<OtherConst...>
                       ::template Iterator<Args..., typename std::conditional<FirstConst || std::is_const<FirstT>{},
                         typename FirstT::const_iterator, typename FirstT::iterator>::type>::type;
        };
    };
};

template <typename...>
struct TupleToRange_;

template <>
struct TupleToRange_<> {
    static constexpr std::size_t MaxIndex = -1;
    template <template <std::size_t...> class Tp>
    using pass = Tp<>;
};

template <typename FirstType, typename... OtherTypes>
struct TupleToRange_<FirstType,OtherTypes...> {
    static constexpr std::size_t MaxIndex = TupleToRange_<OtherTypes...>::MaxIndex + 1;
    template <template <std::size_t...> class Tp>
    struct PassHelper {
        template <std::size_t... a>
        using T = Tp<a..., MaxIndex>;
        using type = typename TupleToRange_<OtherTypes...>::template pass<T>;
    };
    template <template <std::size_t...> class Tp>
    using pass = typename PassHelper<Tp>::type;
};

template <std::size_t... Values>
struct PassHelperFunc_ {
    template <typename Callable, typename Tuple>
    static auto pass ( Callable&& callable, Tuple&& tuple )
   -> decltype(callable(std::get<Values>(std::forward<Tuple>(tuple))...)) { // GCC 4.8.2 needs this
        return callable(std::get<Values>(std::forward<Tuple>(tuple))...);
    }
};
template <typename... Types>
using PassHelperWrapper_ = typename TupleToRange_<Types...>::template pass<PassHelperFunc_>;

namespace ITupleIterator_Lambdas {
    template <template <typename...> class Tp>
    struct func0 {
        template <typename... Args>
        auto operator() ( Args... args ) -> Tp<decltype(*args)...> { return Tp<decltype(*args)...>{*args...}; }
    };
    struct func1 {
        template <typename... Args>
        void operator() ( Args&... args ) { for ( std::nullptr_t i: { (++args, nullptr)... } ) (void)i; }
    };
    struct func2 {
        template <typename... Args>
        void operator() ( Args&... args ) { for ( std::nullptr_t i: { (args++, nullptr)... } ) (void)i; }
    };
    struct func3 {
        template <typename... Args>
        void operator() ( Args&... args ) { for ( std::nullptr_t i: { (--args, nullptr)... } ) (void)i; }
    };
    struct func4 {
        template <typename... Args>
        void operator() ( Args&... args ) { for ( std::nullptr_t i: { (args--, nullptr)... } ) (void)i; }
    };
}
template <typename IterType, template <typename...> class Tp, typename... Types>
struct ITupleIterator_ : IterType {
    using IterType::IterType;
    template <typename Callable>
    auto pass ( Callable&& callable ) {
        return PassHelperWrapper_<Types...>::pass(std::forward<Callable>(callable), *this);
    }
    auto operator* () {
        return pass ( ITupleIterator_Lambdas::func0<Tp>{} );
    }
    ITupleIterator_& operator++ () {
        pass ( ITupleIterator_Lambdas::func1{} );
        return *this;
    }
    ITupleIterator_ operator++ (int) {
        ITupleIterator_ ret = *this;
        pass ( ITupleIterator_Lambdas::func2{} );
        return ret;
    }
    ITupleIterator_& operator-- () {
        pass ( ITupleIterator_Lambdas::func3{} );
        return *this;
    }
    ITupleIterator_ operator-- (int) {
        ITupleIterator_ ret = *this;
        pass ( ITupleIterator_Lambdas::func4{} );
        return ret;
    }
};

namespace _ituple_lambdas {
    template <typename...>
    struct FirstArg;
    template <typename First, typename... Other>
    struct FirstArg<First,Other...> {
        std::size_t operator() ( First&& a, Other&&... ) { return a; }
    };
    template <>
    struct FirstArg<> {
        std::size_t operator()() { return 0; }
    };
    template <typename... Args>
    std::size_t _first_arg ( Args&&... args ) { return FirstArg<Args...>{} ( std::forward<Args>(args)... ); }
    struct size_get {
        template <typename... Args>
        std::size_t operator() ( Args&... args ) { return _first_arg(args.size()...); }
    };
    struct size_all_eq {
        template <typename... Args>
        bool operator() ( Args&... args ) { return all_eq(args.size()...); }
    };
    template <typename TupleIterator>
    struct begin {
        template <typename... Args>
        TupleIterator operator() ( Args&... args ) { return TupleIterator{args.begin()...}; }
    };
    template <typename TupleIterator>
    struct end {
        template <typename... Args>
        TupleIterator operator() ( Args&... args ) { return TupleIterator{args.end()...}; }
    };
    template <typename TupleIterator>
    struct rbegin {
        template <typename... Args>
        std::reverse_iterator<TupleIterator> operator() ( Args&... args ) {
            return std::reverse_iterator<TupleIterator>{TupleIterator{args.rbegin().base()...}};
        }
    };
    template <typename TupleIterator>
    struct rend {
        template <typename... Args>
        std::reverse_iterator<TupleIterator> operator() ( Args&... args ) {
            return std::reverse_iterator<TupleIterator>{TupleIterator{args.rend().base()...}};
        }
    };
}

template <template <typename...> class Tp, typename... Types>
class ituple {
    template <typename> struct TemplatedTrue { static constexpr bool value = true; };
    template <typename> struct TemplatedFalse { static constexpr bool value = false; };
    template <typename Callable>
    auto pass ( Callable&& callable ) const {
        return PassHelperWrapper_<Types...>::pass(std::forward<Callable>(callable), tuple);
    }
    template <bool... Const>
    using tuple_iterator = ITupleIterator_<typename ITupleHelper_<Tp, Types...>
                                         ::template IteratorHelper<Const...>
                                         ::template Iterator<>::type, Tp, Types...>;

public:
    using iterator = tuple_iterator<TemplatedFalse<Types>::value...>;
    using const_iterator = tuple_iterator<TemplatedTrue<Types>::value...>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    ituple ( Tp<Types...>& tuple ) : tuple(tuple) {
        if ( !pass ( _ituple_lambdas::size_all_eq{} ) )
            throw std::invalid_argument{"ituple: non-matching sizes"};
    }
    std::size_t size() const { return pass ( _ituple_lambdas::size_get{} ); }

    template <std::nullptr_t, bool... Const>
    tuple_iterator<Const...> begin() { return pass ( _ituple_lambdas::begin<tuple_iterator<Const...>>{} ); }
    template <std::nullptr_t, bool... Const>
    tuple_iterator<Const...> end() { return pass ( _ituple_lambdas::end<tuple_iterator<Const...>>{} ); }
    template <std::nullptr_t, bool... Const>
    std::reverse_iterator<tuple_iterator<Const...>> rbegin() { return pass ( _ituple_lambdas::rbegin<tuple_iterator<Const...>>{} ); }
    template <std::nullptr_t, bool... Const>
    std::reverse_iterator<tuple_iterator<Const...>> rend() { return pass ( _ituple_lambdas::rend<tuple_iterator<Const...>>{} ); }

    iterator begin() { return begin<nullptr, TemplatedFalse<Types>::value...>(); }
    iterator end() { return end<nullptr, TemplatedFalse<Types>::value...>(); }
    reverse_iterator rbegin() { return rbegin<nullptr, TemplatedFalse<Types>::value...>(); }
    reverse_iterator rend() { return rend<nullptr, TemplatedFalse<Types>::value...>(); }

    const_iterator begin() const {
        return const_cast<ituple*>(this)->begin<nullptr, TemplatedTrue<Types>::value...>();
    }
    const_iterator end() const {
        return const_cast<ituple*>(this)->end<nullptr, TemplatedTrue<Types>::value...>();
    }
    const_reverse_iterator rbegin() const {
        return const_cast<ituple*>(this)->rbegin<nullptr, TemplatedTrue<Types>::value...>();
    }
    const_reverse_iterator rend() const {
        return const_cast<ituple*>(this)->rend<nullptr, TemplatedTrue<Types>::value...>();
    }

    const_iterator cbegin() const { return begin(); }
    const_iterator cend() const { return end(); }
    const_reverse_iterator crbegin() const { return rbegin(); }
    const_reverse_iterator crend() const { return rend(); }

private:
    Tp<Types...>& tuple;
};

template <template <typename...> class Tp, typename... Types>
class const_ituple {
    template <typename> struct TemplatedTrue { static constexpr bool value = true; };
    template <typename Callable>
    auto pass ( Callable&& callable ) const {
        return PassHelperWrapper_<Types...>::pass(std::forward<Callable>(callable), tuple);
    }
    template <bool... Const>
    using tuple_iterator = ITupleIterator_<typename ITupleHelper_<Tp, Types...>
                                         ::template IteratorHelper<Const...>
                                         ::template Iterator<>::type, Tp, Types...>;

public:
    using const_iterator = tuple_iterator<TemplatedTrue<Types>::value...>;
    using iterator = const_iterator;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using reverse_iterator = std::reverse_iterator<iterator>;

    const_ituple ( const Tp<Types...>& tuple ) : tuple{tuple} {
        if ( !pass ( _ituple_lambdas::size_all_eq{} ) )
            throw std::invalid_argument{"const ituple: non-matching sizes"};
    }
    std::size_t size() const { return pass ( _ituple_lambdas::size_get{} ); }

    const_iterator cbegin() const { return pass ( _ituple_lambdas::begin<const_iterator>{} ); }
    const_iterator cend() const { return pass ( _ituple_lambdas::end<const_iterator>{} ); }
    const_reverse_iterator crbegin() const { return pass ( _ituple_lambdas::rbegin<const_iterator>{} ); }
    const_reverse_iterator crend() const { return pass ( _ituple_lambdas::rend<const_iterator>{} ); }

    const_iterator begin() const { return cbegin(); }
    const_iterator end() const { return cend(); }
    const_reverse_iterator rbegin() const { return crbegin(); }
    const_reverse_iterator rend() const { return crend(); }

private:
    const Tp<Types...>& tuple;
};

template <template <typename...> class Tp, typename... Types>
class rvalue_ituple {
    template <typename> struct TemplatedTrue { static constexpr bool value = true; };
    template <typename> struct TemplatedFalse { static constexpr bool value = false; };
    template <typename Callable>
    auto pass ( Callable&& callable ) const {
        return PassHelperWrapper_<Types...>::pass(std::forward<Callable>(callable), tuple);
    }
    template <bool... Const>
    using tuple_iterator = ITupleIterator_<typename ITupleHelper_<Tp, Types...>
                                         ::template IteratorHelper<Const...>
                                         ::template Iterator<>::type, Tp, Types...>;

public:
    using iterator = tuple_iterator<TemplatedFalse<Types>::value...>;
    using const_iterator = tuple_iterator<TemplatedTrue<Types>::value...>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    rvalue_ituple ( Tp<Types...>&& tuple ) : tuple(std::forward<Tp<Types...>>(tuple)) {
        if ( !pass ( _ituple_lambdas::size_all_eq{} ) )
            throw std::invalid_argument{"rvalue ituple: non-matching sizes"};
    }
    std::size_t size() const { return pass ( _ituple_lambdas::size_get{} ); }

    template <std::nullptr_t, bool... Const>
    tuple_iterator<Const...> begin() { return pass ( _ituple_lambdas::begin<tuple_iterator<Const...>>{} ); }
    template <std::nullptr_t, bool... Const>
    tuple_iterator<Const...> end() { return pass ( _ituple_lambdas::end<tuple_iterator<Const...>>{} ); }
    template <std::nullptr_t, bool... Const>
    std::reverse_iterator<tuple_iterator<Const...>> rbegin() { return pass ( _ituple_lambdas::rbegin<tuple_iterator<Const...>>{} ); }
    template <std::nullptr_t, bool... Const>
    std::reverse_iterator<tuple_iterator<Const...>> rend() { return pass ( _ituple_lambdas::rend<tuple_iterator<Const...>>{} ); }

    iterator begin() { return begin<nullptr, TemplatedFalse<Types>::value...>(); }
    iterator end() { return end<nullptr, TemplatedFalse<Types>::value...>(); }
    reverse_iterator rbegin() { return rbegin<nullptr, TemplatedFalse<Types>::value...>(); }
    reverse_iterator rend() { return rend<nullptr, TemplatedFalse<Types>::value...>(); }

    const_iterator begin() const {
        return const_cast<rvalue_ituple*>(this)->begin<nullptr, TemplatedTrue<Types>::value...>();
    }
    const_iterator end() const {
        return const_cast<rvalue_ituple*>(this)->end<nullptr, TemplatedTrue<Types>::value...>();
    }
    const_reverse_iterator rbegin() const {
        return const_cast<rvalue_ituple*>(this)->rbegin<nullptr, TemplatedTrue<Types>::value...>();
    }
    const_reverse_iterator rend() const {
        return const_cast<rvalue_ituple*>(this)->rend<nullptr, TemplatedTrue<Types>::value...>();
    }

    const_iterator cbegin() const { return begin(); }
    const_iterator cend() const { return end(); }
    const_reverse_iterator crbegin() const { return rbegin(); }
    const_reverse_iterator crend() const { return rend(); }

private:
    Tp<Types...> tuple;
};

template <template <typename...> class Tp, typename... Types>
ituple<Tp, Types...> to_ituple ( Tp<Types...>& tuple ) { return tuple; }
template <template <typename...> class Tp, typename... Types>
const_ituple<Tp, Types...> to_ituple ( const Tp<Types...>& tuple ) { return tuple; }
template <template <typename...> class Tp, typename... Types>
rvalue_ituple<Tp, Types...> to_ituple ( Tp<Types...>&& tuple ) { return std::forward<Tp<Types...>>(tuple); }

template <typename Tp1, typename Tp2>
std::pair<Tp1&&, Tp2&&> forward_as_pair ( Tp1&& a, Tp2&& b ) {
    return {std::forward<Tp1>(a), std::forward<Tp2>(b)};
}
template <typename Tp1, typename Tp2>
rvalue_ituple<std::pair, Tp1&&, Tp2&&> forward_as_ipair ( Tp1&& a, Tp2&& b ) {
    return forward_as_pair(std::forward<Tp1>(a), std::forward<Tp2>(b));
}
template <typename... Types>
rvalue_ituple<std::tuple, Types&&...> forward_as_ituple ( Types&&... args ) {
    return std::forward_as_tuple(std::forward<Types>(args)...);
}

template <template <typename...> class Tp, typename... Types>
struct ctuple : Tp<Types...> {
    template <typename... Args>
    ctuple ( Args&&... args ) : Tp<Types...>(std::forward<Args>(args)...) {}
    template <typename Res>
    struct construct {
        template <typename... Args>
        Res operator() ( Args&&... args ) { return Res{std::forward<Args>(args)...}; }
    };
    template <typename Res>
    operator Res() && { return PassHelperWrapper_<Types...>::pass(construct<Res>{}, std::move(*this)); }
};
template <template <typename...> class Tp, typename... Types>
ctuple<Tp, Types...> to_ctuple ( Tp<Types...>&& tuple ) { return std::forward<Tp<Types...>>(tuple); }
}

#define foreach2(I, A, B) for ( auto&& I: non_std::forward_as_ipair(A, B) )
#define foreach(I, ...) for ( auto&& I: non_std::forward_as_ituple(VA_ARGS) )
#define foreach(A, ...) for ( auto&& foreach_iterator: non_std::forward_as_ituple(VA_ARGS) ) \
    for ( bool _foreach_guard = true; _foreach_guard; ) for ( A = non_std::to_ctuple( \
        std::move(foreach_iterator) ); _foreach_guard; _foreach_guard = false )

#endif // NON_STD_ITUPLE
